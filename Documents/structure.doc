.

ğŸ« School Management System â€” Project Architecture

This project is a modular, service-oriented Next.js + Prisma application that manages multi-branch schools.
It follows Clean Architecture principles, separating domain logic, data access, services, and routes into distinct layers for scalability and maintainability.

ğŸ§­ Overview

The system is organized around modules (e.g., school, branch, student, etc.), each containing:

Repositories â€” interact directly with the database via Prisma

Services â€” contain business logic

Routes â€” handle API requests and responses

Additionally, the app leverages Next.jsâ€™s App Router, Server Components, and API routes under src/app/api.

ğŸ“‚ Project Structure
src/
â”œâ”€â”€ app/
â”‚   â”œâ”€â”€ api/
â”‚   â”‚   â”œâ”€â”€ schools/
â”‚   â”‚   â”‚   â””â”€â”€ route.ts            # API endpoint â†’ /api/schools
â”‚   â”‚   â”œâ”€â”€ branches/
â”‚   â”‚   â”‚   â””â”€â”€ route.ts            # API endpoint â†’ /api/branches
â”‚   â”‚   â””â”€â”€ ...
â”‚   â”œâ”€â”€ (dashboard)/
â”‚   â”‚   â”œâ”€â”€ schools/
â”‚   â”‚   â”‚   â””â”€â”€ page.tsx            # UI page â†’ /schools
â”‚   â”‚   â”œâ”€â”€ branches/
â”‚   â”‚   â”‚   â””â”€â”€ page.tsx            # UI page â†’ /branches
â”‚   â”‚   â””â”€â”€ ...
â”‚   â””â”€â”€ layout.tsx
â”‚
â”œâ”€â”€ lib/
â”‚   â”œâ”€â”€ prisma.ts                    # Singleton Prisma client instance
â”‚   â”œâ”€â”€ utils/
â”‚   â”‚   â””â”€â”€ time.ts                  # Helper for timestamps (e.g. nowTimestamp)
â”‚   â””â”€â”€ ...
â”‚
â”œâ”€â”€ modules/
â”‚   â”œâ”€â”€ core/
â”‚   â”‚   â”œâ”€â”€ repositories/
â”‚   â”‚   â”‚   â””â”€â”€ base-repository.ts   # Generic CRUD repository (extends Prisma model)
â”‚   â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”‚   â””â”€â”€ base-service.ts      # Generic CRUD service (wraps repositories)
â”‚   â”‚   â””â”€â”€ routes/
â”‚   â”‚       â””â”€â”€ base-route.ts        # Generic API route handler (Next.js API wrapper)
â”‚   â”‚
â”‚   â”œâ”€â”€ school/
â”‚   â”‚   â”œâ”€â”€ repositories/
â”‚   â”‚   â”‚   â””â”€â”€ school-repository.ts # Prisma repository for School model
â”‚   â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”‚   â””â”€â”€ school-service.ts    # Business logic for schools
â”‚   â”‚   â””â”€â”€ routes/
â”‚   â”‚       â””â”€â”€ school-route.ts      # API controller for school endpoints
â”‚   â”‚
â”‚   â”œâ”€â”€ branch/
â”‚   â”‚   â”œâ”€â”€ repositories/
â”‚   â”‚   â”‚   â””â”€â”€ branch-repository.ts # Branch repository with school relation
â”‚   â”‚   â””â”€â”€ ...
â”‚   â”‚
â”‚   â””â”€â”€ ...
â”‚
â””â”€â”€ prisma/
    â””â”€â”€ schema.prisma                # Prisma schema defining School, Branch, etc.

ğŸ§© Architectural Layers
1. Repository Layer (BaseRepository)

Handles database access using Prisma.

// Example: BaseRepository
export abstract class BaseRepository<T> {
  constructor(protected model: any) {}
  async create(data: Partial<T>) { return this.model.create({ data }); }
  async list(params?: any) { return this.model.findMany(params); }
  async findById(id: string) { return this.model.findUnique({ where: { id } }); }
  async update(id: string, data: Partial<T>) { return this.model.update({ where: { id }, data }); }
  async delete(id: string) { return this.model.delete({ where: { id } }); }
}


Each module (e.g., SchoolRepository, BranchRepository) extends this to handle its specific Prisma model.

2. Service Layer (BaseService)

Contains business logic and orchestrates multiple repositories.

export class SchoolService extends BaseService<School, SchoolRepository> {
  constructor(private branchRepo = new BranchRepository()) {
    super(new SchoolRepository());
  }

  async addBranch(data) {
    return this.branchRepo.create({
      ...data,
      created_at: nowTimestamp(),
      updated_at: nowTimestamp(),
    });
  }
}

3. Route Layer (BaseRoute)

Handles HTTP requests/responses, wrapping logic in consistent API responses.

export abstract class BaseRoute<TService> {
  constructor(protected service: TService) {}

  protected jsonResponse(data: any, status = 200) {
    return NextResponse.json({ success: true, data }, { status });
  }

  protected errorResponse(error: any, status = 500) {
    return NextResponse.json({ success: false, message: error?.message }, { status });
  }
}


Then, each module implements its own route, e.g.:

export class SchoolRoute extends BaseRoute<SchoolService> {
  constructor() {
    super(new SchoolService());
  }

  async handleGet() {
    const data = await this.service.getAll();
    return this.jsonResponse(data);
  }
}

ğŸ§  Request Flow Example

When you hit:

GET /api/schools


The following happens:

route.ts

SchoolRoute.handleGet() is called.

SchoolRoute

Calls SchoolService.getAll().

SchoolService

Calls SchoolRepository.list().

SchoolRepository

Executes prisma.school.findMany() and returns data.

ğŸ§± Key Design Principles

Modular architecture â€” each feature (school, branch, etc.) is isolated.

Separation of concerns â€” repositories (data), services (logic), routes (API).

Generic base classes â€” promote code reuse and consistency.

Extendable â€” easily add new modules (students, teachers, classes, etc.).

Next.js 15 App Router compatible â€” works seamlessly with route.ts and page.tsx.

ğŸ§© Example Extension

To add a Student module, youâ€™d do:

src/modules/student/
â”œâ”€â”€ repositories/student-repository.ts
â”œâ”€â”€ services/student-service.ts
â””â”€â”€ routes/student-route.ts


Each extends the base classes:

StudentRepository extends BaseRepository<Student>

StudentService extends BaseService<Student, StudentRepository>

StudentRoute extends BaseRoute<StudentService>

ğŸš€ API & Page Routing
Type	Path	Source	Description
API	/api/schools	src/app/api/schools/route.ts	CRUD endpoints for schools
API	/api/branches	src/app/api/branches/route.ts	Manage branches
Page	/schools	src/app/(dashboard)/schools/page.tsx	Frontend school dashboard
Page	/branches	src/app/(dashboard)/branches/page.tsx